/**
 * Nekocurl driver nekocurl
 * Copyright 2017 Charlotte Dunois, All Rights Reserved
 *
 * Website: https://github.com/CharlotteDunois/node-nekocurl
*/

const http = require('http');
const https = require('https');
const path = require('path');
const querystring = require('querystring');
const { PassThrough, Readable } = require('stream');
const URL = require('url');
const zlib = require('zlib');

const FormData = require(path.join(__dirname, '..', 'formdata.js'));

class NekocurlDriver extends Readable {
    constructor(options, driverOptions = { }) {
        super();
        
        this.options = options;
        this.driverOptions = driverOptions;
        
        const url = URL.parse(options.url);
        url.method = options.method;
        url.headers = options.headers;
        
        this.apply();
        this.request = (url.protocol.includes('https') === true ? https : http).request(url);
    }
    
    send() {
        const error = new Error(); // just to get an useful stack trace, maybe
        const request = this.request;
        
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            
            const handleError = (err) => {
                if(!err) {
                    err = error;
                    err.message = 'An unknown error occured';
                }
                
                err.request = request;
                return reject(err);
            };
            
            request.once('abort', handleError).once('aborted', handleError).once('error', handleError).once('response', (response) => {
                this.response = response;
                const dataChunks = [ ];
                
                this.doUnzip(response, dataChunks).once('end', () => {
                    this.push(null);
                    
                    if(this.doRedirect(response) !== false) {
                        return undefined;
                    }
                    
                    const body = Buffer.concat(dataChunks);
                    const text = body.toString();
                    
                    const res = {
                        request: request,
                        body: this.makeBody(response, body, text),
                        text: text,
                        headers: response.headers,
                        status: response.statusCode,
                        statusText: (response.statusText || http.STATUS_CODES[response.statusCode])
                    };
                    
                    if(res.status >= 200 && res.status < 300) {
                        return resolve(res);
                    }
                    
                    error.message = (res.status+' '+res.statusText).trim();
                    return reject(Object.assign(error, res));
                });
            });
            
            request.end((this.options.data ? (this.options.data.finalize ? this.options.data.finalize() : this.options.data) : undefined));
        });
        
        return this.promise;
    }
    
    apply() {
        const options = this.options;
        
        if(options.files.length > 0) {
            if(!this.form) {
                this.form = new FormData();
                options.data = this.form;
            }
            
            options.headers['content-type'] = 'multipart/form-data; boundary='+this.form.boundary;
            
            for(let i = 0; i < options.files.length; i++) {
                this.attachFile(options.files[i]);
            }
        }
        
        if(options.method !== 'HEAD' && this.driverOptions.encoding !== null) {
            options.headers['accept-encoding'] = 'gzip, deflate';
        }
    }
    
    attachFile({ name, data, filename }) {
        this.form.append(name, data, filename);
        return this;
    }
    
    doRedirect(response) {
        if(this.driverOptions.followRedirects !== false && [ 301, 302, 303, 307, 308 ].includes(response.statusCode)) {
            if([ 301, 302, 303 ].includes(response.statusCode)) {
                if(response.statusCode === 303 || this.options.method !== 'HEAD') {
                    this.options.method = 'GET';
                }
                
                this.options.data = null;
            }
            
            return driverNekocurl(Object.assign(this.options, { url: this.getNewURL(response, URL.parse(this.options.url)) }), this.driverOptions).then((resp) => this.resolve(resp)).catch((error) => this.request.emit('error', error)); // eslint-disable-line no-use-before-define
        }
        
        return false;
    }
    
    doShouldUnzip(response) {
        if(response.statusCode === 204 || response.statusCode === 304 || response.headers['content-length'] === '0') {
            return false;
        }
        
        return /^\s*(?:deflate|gzip)\s*$/.test(response.headers['content-encoding']);
    }
    
    doUnzip(response, dataChunks) {
        const stream = new PassThrough();
        
        if(this.doShouldUnzip(response) === true) {
            response.pipe(zlib.createUnzip({ flush: zlib.Z_SYNC_FLUSH, finishFlush: zlib.Z_SYNC_FLUSH })).pipe(stream);
        } else {
            response.pipe(stream);
        }
        
        stream.on('data', (chunk) => {
            if(!this.push(chunk)) {
                this.pause();
            }
            
            dataChunks.push(chunk);
        });
        
        return stream;
    }
    
    getNewURL(response, urlobj) {
        if(/^https?:\/\//i.test(response.headers.location)) {
            return response.headers.location;
        }
        
        return URL.resolve(URL.format(urlobj), response.headers.location);
    }
    
    makeBody(response, buffer, text) {
        let body = buffer;
        
        const type = String(response.headers['content-type']).split(';')[0].trim();
        switch(type) {
            case 'application/json':
                try {
                    body = JSON.parse(text);
                } catch(err) {
                    /* continue regardless of error */
                }
            break; // eslint-disable-line indent
            case 'application/x-www-form-urlencoded':
                body = querystring.parse(text);
            break; // eslint-disable-line indent
        }
        
        return body;
    }
    
    _read() {
        this.resume();
        if(this.response) {
            return;
        }
        
        if(!this.promise) {
            this.send();
        }
        
        this.promise.catch((err) => this.emit('error', err));
    }
}

function driverNekocurl(options, driverOptions) {
    return (new NekocurlDriver(options, (driverOptions ? driverOptions : { }))).send();
}

function driverNekocurlStream(options, driverOptions) {
    return new NekocurlDriver(options, (driverOptions ? driverOptions : { }));
}

module.exports = {
    multiple: false,
    streamable: 'driverStream',
    driver: driverNekocurl,
    driverStream: driverNekocurlStream,
    NekocurlDriver: NekocurlDriver
};
